function setInvKin(params)
%setInvKin: Creates function to evaluate inverse kinematics (x2q) based
%on user supplied definition.
%   Detailed explanation goes here

num = params.num;
d = params.d;
L = params.L;

%% (USER EDIT) Symbolically defined inverse kinematics function

q = sym('q', [2*params.num, 1], 'real'); 
x = sym('x', [6,1], 'real');

% % 2 DOF rotation and translation rig (axes aligned)
% q(1:2:end) = (x(3) - params.deff(3))*ones(params.num,1);  % dl
% q(2:2:end) = x(4)*ones(params.num,1);  % dphi

% % 2 DOF rotation and translation rig (axes not aligned)
% for i = 1 : num
%     q(2*(i-1) + 1) = -L(i) + sqrt( (L(i)+x(3))^2 + ( x(4)*(d(1,i) + d(2,i)) )^2);
%     q(2*(i-1) + 2) = x(4);
% end

% 6 DOF module with compliant spine
for i = 1 : num
    q(2*(i-1) + 1) = -L(i) + sqrt( ( L(i) - sin(x(5))*d(1,i) + cos(x(5))*sin(x(6))*d(2,i) )^2 + (x(4)*(d(1,i) + d(2,i)))^2);
    q(2*(i-1) + 2) = x(4);
end

%% (USER EDIT) Symbolically definded coupling between states




% 2 DOF rotation and translation rig (axes not aligned)
xind = sym('xind', [2,1], 'real'); % size should be number of independent components
xcoupled = [0,...
            0,...
            -L(1) + sqrt( (L(1) + xind1)^2 - (xind2*(d(1,i) + d(2,i)))^2 ),...
            xind2,...
            0,...
            0,];
            
        
% 6 DOF module with compliant spine
xind = sym('xind', [3,1], 'real'); % size should be number of independent components
xcoupled = [L(1)/2 * (cos(xind1)*sin(xind2)*cos(xind3) + sin(xind1)*sin(xind3)),...
            L(1)/2 * (sin(xind1)*sin(xind2)*cos(xind3) - cos(xind1)*sin(xind3)),...
            L(1)/2 * (cos(xind2)*cos(xind3) - 1),...
            xind1,...
            xind2,...
            xind3];

%% Convert symbolic expression to matlab function
matlabFunction(q, 'File', 'x2q', 'Vars', {x});  
matlabFunction(xcoupled, 'File', 'xind2xcoupled', 'Vars', {xind});

end

