function setJacobians(params)
%setJacobians: Defines the Jacobians of the system symbolically then
%creates Matlab functions to evaluate them.
%   Detailed explanation goes here

p = params.p
%% Connect Block Jacobian

alpha = sym('alpha', [p,1, 'real']);
q = alpha2q_sym(alpha, params);

% The state of the ith actuator of the kth module (q_ki) in terms of the state of
% the kth module in local coordinate frame (X_k).
s_ki = -L_k + sqrt( (L_k - sin(theta_k)*a_ki + cos(theta_k)*sin(psi_k)*b_ki)^2 + (a_ki^2 + b_ki^2)*phi_k^2 );
w_ki = phi_k;

q_ki = [s_ki, w_ki]';
X_k = [x_k, y_k, z_k, psi_k, theta_k, phi_k]';

% define the module Jacobian
J_ki = jacobian(q_ki, X_k);

% Create Matlab function for evaluating J_ki
% matlabFunction(J_ki, 'File', 'J_ki', 'Vars', {[x_k, y_k, z_k, psi_k, theta_k, phi_k], [a_ki, b_ki], L_k});
matlabFunction(J_ki, 'File', 'J_ki', 'Vars', {X_k, [a_ki, b_ki], L_k});



%% New version of Manipulator Jacobian that is a function of x0 not x

p = params.p;   % total number of modules in manipulator

% state vectors (in local and global coordinates)
x = sym('x', [6*p,1], 'real');      % local coordinates
x0 = sym('x0', [6*p,1], 'real');    % global coordinates

x = x02x_sym(x0, params);   % define x in terms of x0

% define the manipulator Jacobian
Jx = jacobian(x, x0);

% Create Matlab function for evaluating Jx
matlabFunction(Jx, 'File', 'Jx', 'Vars', {x0}, 'Optimize', false);


%% Jacobian to transfer between orientation and position velocities

syms psi_ theta_ phi_ x y z L_ real

x_orient = [psi_, theta_, phi_]';
x_pos = euler2cart(x_orient, L_);

% define the Jacobian
Jorient2pos =  jacobian(x_pos, x_orient);

% Create Matlab function for evaluating Jx
matlabFunction(Jorient2pos, 'File', 'Jorient2pos', 'Vars', {x_orient, L_}, 'Optimize', false);

end

