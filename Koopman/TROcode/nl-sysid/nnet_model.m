function [y1,xf1,xf2] = nnet_model(x1,x2,xi1,xi2)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 29-Apr-2020 18:45:17.
%
% [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 2xTS matrix, input #2
%   xi1 = 3x1 matrix, initial 1 delay states for input #1.
%   xi2 = 2x1 matrix, initial 1 delay states for input #2.
% and returns:
%   y1 = 2xTS matrix, output #1
%   xf1 = 3x1 matrix, final 1 delay states for input #1.
%   xf2 = 2x1 matrix, final 1 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0;0;0];
x1_step1.gain = [0.285714285714286;0.285714285714286;0.285714285714286];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-7.25060854359134;-4.72939356808897];
x2_step1.gain = [0.13382769025303;0.170239396405538];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.670535877487215215;-0.94199054307794483076;-0.6777734872477375605;0.06894589089177798058;-1.0352886305612696294;0.55991104527284085712;-0.48342494406219621572;-2.0139570792752059525;1.163616871373317263;-1.1936959353355280911];
IW1_1 = [0.40144612772424081992 -0.16503101668446870653 0.09520617539238133975;-0.9054265819718332331 0.11728278697305470624 0.29466761354841453091;0.14181083018103651794 -0.36013477476277783174 0.58582056080541144993;0.3302729688874909697 -0.055621903598910164834 -0.074766617836789450724;-0.61091314047691636091 0.0028534810523717334119 0.14903483968072361865;-0.44454906738896532437 -0.0035428589215665681408 0.15877085695046533331;-1.2011002438220288457 0.56878129002828237137 0.04343862901097790552;-1.2157353856133961134 -0.26635768731283848698 1.484217827503910403;0.59621069319191621894 -2.4768130707333821938 -1.3990774410642805581;-0.79142373350332617665 -0.048826465373500195499 -0.067581271484067700905];
IW1_2 = [0.53051764672441226178 0.60506626244969541339;-0.24888096993935610035 -1.9698612279963791938;-0.15505586221733755337 0.52492880486047932553;0.21835940016888799597 0.35356764469289042596;-1.2184794856072285185 -0.60581703492834415581;-0.16145648229774520188 -0.96615064932003524856;-0.62698951180810114092 -1.9948475866391632838;-3.082624214717708977 -0.91602106330836641224;0.26376870178994715754 -1.4347587451803160974;-1.6330851819541301051 -0.64437869300139816175];

% Layer 2
b2 = [0.54585494809161660967;0.88313006230564228272];
LW2_1 = [2.2574530629286404526 0.10267766152195552387 -0.68178755281666980625 -2.6049446776286737659 -1.8378142104549892721 0.28378865170236439175 -0.12744229374931143051 0.72070524178235739754 0.002691300377476365472 0.34513348446922398338;0.8995776591757520535 -0.49817268449027862776 -0.18812084671492637633 -3.8109731374506674584 -0.45963868892510445496 -1.5263599379686436652 -0.16984506651396077959 0.22279273377475022899 0.0016360108517750381139 0.031047483891102768683];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.13382769025303;0.170239396405538];
y1_step1.xoffset = [-7.25060854359134;-4.72939356808897];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(2,1)];

% Allocate Outputs
y1 = zeros(2,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-1-1,2)+1),3,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-1-1,2)+1),2,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
