function [Y,Xf,Af] = nnet_2019_09_24_19_46(X,~,~)
%NNET_2019_09_24_19_46 neural network simulation function.
%
% Auto-generated by MATLAB, 24-Sep-2019 19:46:04.
% 
% [Y] = nnet_2019_09_24_19_46(X,~,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 6xQ matrix, input #1 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.909751395852713;-2.56515020070767;-1.62765341697827;-0.857407837487866;-2.56143395805095;-1.53711061994064];
x1_step1.gain = [1.07370193474617;0.400736581981864;0.599413266438315;1.10429023854803;0.407980449543802;0.620424291857661];
x1_step1.ymin = -1;

% Layer 1
b1 = [0.96485230696711588028;1.4327951804280794068;-0.72107134982044207572;0.93639876564039281615;-1.4242513683439943506;0.21665931778563093935;1.1119752860555804919;0.91519215521103280953;-0.81477918412953820315;0.95612258444543563041];
IW1_1 = [1.3515721981709873933 1.2180604799202681132 0.28707539350260119493 4.1729584812973889996 5.3636752845360202713 1.830250647672657216;0.84891625681719951046 3.2717861942012165244 2.4594519873026157164 0.78688582528417572171 4.4686784924279372433 4.1440752622884167167;3.712227840647908117 3.5947194266164510523 0.93352023161112418492 1.2777036551730540648 1.0669677398772663413 0.22508322993592913552;4.8433732843160903769 11.519770153251764455 5.6263631756814911355 -9.1940368209246567943 -13.45292634517260133 -5.008852266144703691;1.6385752834856672777 4.2280121129415277892 2.1525127685306455483 0.11585415332120750642 0.73382744918448716831 0.64613056508456678806;-4.0093048583559056652 -3.801425489583604822 -0.92991104330964047264 -0.021542101909370527796 0.10290252296197144322 0.02191128580253898922;1.6827856389756106203 1.3534261533868408023 0.26857345730787141047 5.4628778277686347309 8.544245405000761906 3.3708737465652380827;-2.0750281423262619818 -7.8835837624593221307 -6.0446672718646530242 3.6122768023989761943 13.468958371608771074 9.5684672648427628872;1.8314648366423140757 6.4804214054660693733 4.713507785517050408 -2.9904374171912166958 -11.511888531541968561 -8.3853631198977893746;2.4308995985367753967 1.8910459438073923266 0.28989844868673658729 -2.4509348389122989076 -2.566434435412320525 -0.71101110971234671165];

% Layer 2
b2 = [-0.64886453888803929946;7.4728164075514227349;-13.131123805720221753];
LW2_1 = [0.65308892520663897052 -0.041131014644930498358 -1.4873766464524453834 0.00092299583428015756666 -0.38480890713696430661 -1.8352055272143243947 -0.31907334556224470345 -0.0079843448436711164651 -0.019758664546777417181 -0.34589260736472859925;-14.902864172920113006 -0.20498882693049144677 5.6706787434305949702 0.68318334081183240691 -4.6924070305348895005 -1.4138964933307449634 7.6434268024687082033 -0.14269731004887906134 -0.26368173242412762391 -9.3782836567112042303;1.0965661724129902588 7.4383164311255969281 -0.52820033010940303786 -0.020637422805254636293 -7.4447220667236129188 0.06808682762317792847 -0.50808733425111696214 10.548862620516912258 12.162719066221511 0.82237013218137522408];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.357937018179918;0.343718093594474;0.35754986323111];
y1_step1.xoffset = [-2.82437190191646;-2.88700413234842;-2.78523960580505];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
