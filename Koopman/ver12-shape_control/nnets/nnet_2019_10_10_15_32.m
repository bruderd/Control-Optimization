function [Y,Xf,Af] = nnet_2019_10_10_15_32(X,~,~)
%NNET_2019_10_10_15_32 neural network simulation function.
%
% Auto-generated by MATLAB, 10-Oct-2019 15:32:05.
% 
% [Y] = nnet_2019_10_10_15_32(X,~,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 6xQ matrix, input #1 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-1.32113880804237;-1.27503539837562;-1.18817916448048;-0.928038264067655;-1;-1];
x1_step1.gain = [0.822633420854031;0.833854785567747;0.926003062509369;1.26021758813278;1;1];
x1_step1.ymin = -1;

% Layer 1
b1 = [-2.2945591754316718713;-1.1670548573440169271;1.7750042706172204365;-0.19520886619766988912;-0.13331050179794132204;-0.24724292455665727863;0.86529256531988119061;1.3100335173852739601;0.65384296706260891519;0.95743668066914489057];
IW1_1 = [-0.62307484981729910345 3.1486296165058171859 0.4231299761089977185 0.30504742555814362559 0.39614333477363056213 -2.3218352499123864341;-0.39241899520610512564 0.42523715257947519719 -1.341809795614593348 0.52804464780335991225 0.90094442746573477621 -0.54241066646711122434;-0.17017342855805875357 0.34895711021690456466 0.50636395802789369025 2.3377383449455910736 -3.3057357402647657985 0.69699444124821063884;-0.23732829702497931779 0.34307401957265315495 0.7226249131916284707 0.11353446512401657587 -0.39984847786597621511 -0.91192964917756946797;0.17763564141413684672 0.5985480584413866989 -0.13586278456067202303 -0.87346122107148782554 -0.14927522521672639821 1.5170131853896144936;-0.14770842473378847926 0.41247875110811815791 0.6903373019165398583 -0.35637398638901468528 0.31645967613826703202 -0.85588121981925990855;1.1130111593975724471 -1.1634716299251428584 1.9108242052307340408 0.13474275108185257421 -1.1807069704424664192 0.93764496050658063808;0.79577856705736937926 1.9851571096640492353 0.43804650666882821719 -0.14374882857336349073 1.9587525468356425939 0.49862170628855823074;1.7559564739205768547 0.22513472256414976402 -0.36129159952504519282 1.1023708385955244271 -0.21776275055929311675 1.0339311417296743745;1.1299991508673032925 1.7084108864757883151 1.2957139593475350825 0.26442461076188872315 1.6164079146755963023 0.63817832701827170716];

% Layer 2
b2 = [1.1932165820917477461;0.15596623307657678237;-0.52832571906079095481];
LW2_1 = [-1.127663000084452527 2.9524019267278922563 -0.028353005930497325593 1.2535339960466758136 1.3848947572212060297 0.77245986612112349512 1.6739204163562524386 1.3462029747958643711 -1.0360614528026987902 -1.0499900154574852706;0.27578224397483236396 0.30549018204215494521 0.3310865689824104563 1.3628101229560736218 -0.14413183246584798658 -2.1357112648997791382 -1.2740198571749250522 -2.1933096888180059203 -0.043270204905045094035 3.0864912529143637698;0.049391591639275908565 -0.52811181745424973233 0.17411702058555628136 0.98748338797635581976 -0.37510415254059670254 -1.6308300266630544328 -1.3723932849078090968 -1.7488186811961843325 0.35347125021408271062 2.4534216952916034771];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [1;1;1];
y1_step1.xoffset = [-1;-1;-1];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
