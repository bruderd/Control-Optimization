function [Y,Xf,Af] = nnet_2019_10_10_14_55(X,~,~)
%NNET_2019_10_10_14_55 neural network simulation function.
%
% Auto-generated by MATLAB, 10-Oct-2019 14:55:36.
% 
% [Y] = nnet_2019_10_10_14_55(X,~,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 6xQ matrix, input #1 at timestep ts.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.60493825251753;-0.55355043011164;-0.496540544300019;-1;-1;-1];
x1_step1.gain = [1.69608747311985;1.86472651654328;1.99124055742728;1;1;1];
x1_step1.ymin = -1;

% Layer 1
b1 = [-3.8218488726232857644;-3.1288070561232852462;0.0050705881028275242781;0.02835091953277776855;0.010333068413088690798;0.034404229723737571323;-0.059311042135295241606;-0.99861959593964844117;0.03401351871396690596;-1.1333180069250785582];
IW1_1 = [1.9048779392700310176 -2.4464290930932475199 1.5630819748039652684 -3.6477602831876816403 -1.3815617680418617041 -0.95789032357410819341;-4.6850033955080352399 -2.7883741002308468637 6.7841329965331498286 -3.3814040602541326486 -3.3674601225609861466 1.3658144449083717831;-0.027760845365322250888 0.094496680473870442452 0.10794743382337076976 -0.76961369956476610721 -0.072217222348176818292 -0.038257285028926307779;-0.13574782115466210719 0.30198684704963812964 0.32275073630709816275 -1.9518248095040722223 -1.9002463109190474988 -0.080177847464102558472;-0.15541294379572059836 -0.068905206033345905992 0.013581939256660640128 0.029302575244359925499 0.0070478499822367165692 0.0062414061657013533702;0.40426991289987046496 -0.65097222500636930942 -0.71775942212025500844 -0.027220552791390302538 0.21607331311473126911 0.087362571318275183962;-4.6368467655135763295 3.0964296310367238618 -5.606285561404913409 3.5598709450999437287 -0.21111365156840314339 0.26619101061688765775;0.11317266647054770312 0.018978791361105161462 -0.50252208093888084406 1.134073203135558483 1.1479100392079801818 0.77665947965640402817;0.37965609255938065347 -0.71055834128653416748 -1.0220252429654346216 0.12721961660305836084 0.31066586604874135702 0.12609931476606359158;0.13701709486278484951 0.0333297243837294907 -0.54307737799656441435 1.2864749812384053129 1.3014840476889726339 0.87477039546264756531];

% Layer 2
b2 = [-0.044700535898213024366;0.036004255094497283896;0.08010171286586839634];
LW2_1 = [-0.091916108649492622718 -0.069140977055161798037 -1.2640461813610501807 -0.18461093289179086874 0.38386580470573583579 7.4228236701074807868 -0.05898069304627948789 1.8803125292021047876 -6.415223811578403712 -1.5940665054961122848;-0.11021669026987075679 -0.032320148708149851191 0.63732375921992745482 -0.17306305314707046139 2.4355383005898856297 -2.9370272019508538719 -0.041094007232306217769 1.9634662495272772187 1.306546215424109425 -1.6688860144348736103;-0.070948225927418867576 -0.023732380529727925556 0.1044387632874051175 -0.00091838374920922909942 -8.6437547479481757762 -2.2224355759114082787 -0.0075119365461232233405 1.6889471090378747054 1.3950234033494781638 -1.4381624922884410633];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [1;1;1];
y1_step1.xoffset = [-1;-1;-1];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
  X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
  Q = size(X{1},2); % samples/series
else
  Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
  Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
