function [y1,xf1] = larm_nlinout_1del(x1,xi1)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 22-Jan-2019 20:35:53.
%
% [y1,xf1] = myNeuralNetworkFunction(x1,xi1) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   xi1 = 3x1 matrix, initial 1 delay states for input #1.
% and returns:
%   y1 = 2xTS matrix, output #1
%   xf1 = 3x1 matrix, final 1 delay states for input #1.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0;0;0];
x1_step1.gain = [2.22222222222222;2.22222222222222;2.22222222222222];
x1_step1.ymin = -1;

% Layer 1
b1 = [-4.7113588608378336;4.4284560321424253;-0.31842774923892397;-0.081885017156877682;-12.143021784312845;-3.8020206451012832;-0.15621105245787392;-24.795722997087118;8.7207530624107488;-32.112982565918706];
IW1_1 = [0.80045002826622857 0.22512013078611165 -3.9332776342868656;-0.89871459164912559 -0.22091760586608922 4.4921774052768475;1.675269964449049 -1.7253205305378623 -0.078533248213147985;-1.4474537822101226 0.5275972188060073 0.94240139561210579;1.632230276291311 0.37919264593822333 -10.923527121372196;5.9806787740238487 -4.5707571390253694 8.4997454156892402;-0.10874844541044701 -2.252045766507484 0.29094219157705004;0.35964454617938174 -23.259704818414352 -0.01554751528319741;8.4127906466216533 0.9235562499267046 2.9546741410867203;-30.78466334346848 0.21496399721919787 0.15362001712644491];

% Layer 2
b2 = [4.4080162024219032;-1.2077477306819038];
LW2_1 = [4.8383791080467091 1.7347271947986462 0.03846739427719665 0.23591952653640472 -1.5895585450304011 -0.022786861046519846 0.18205744505482568 1.5516803229123464 0.095637090138587871 1.3718793244916807;-5.9691796780038002 -1.2899722070777071 -0.2624946724940323 -0.098605404237528851 2.8276276975782597 -0.02937859643483328 -0.056920422481311364 -1.2902326789046152 0.025539508843466608 1.9021371555184232];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [1.11239008811694;1.16699751868495];
y1_step1.xoffset = [-0.897930439478848;-0.9];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Allocate Outputs
y1 = zeros(2,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-1-1,2)+1),3,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
