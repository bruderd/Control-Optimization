function [y1,xf1] = snakeNeuralNetworkFunction(x1,xi1)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 11-Sep-2018 12:16:51.
%
% [y1,xf1] = myNeuralNetworkFunction(x1,xi1) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   xi1 = 1x2 matrix, initial 2 delay states for input #1.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 1x2 matrix, final 2 delay states for input #1.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = 0.000308814709826345;
x1_step1.gain = 20.0963882772686;
x1_step1.ymin = -1;

% Layer 1
b1 = [-3.700342166450334;3.2189648401888711;-4.0577036474362522;0.17241440942349223;0.74655523877808783;0.18536367818425681;0.34124537553139428;-2.449217819212572;-1.7950453791029883;0.74263095501803345];
IW1_1 = [5.861753274272874 -1.228300081555961;1.7076026316596258 -5.6336561808391989;0.8579691606306642 6.6812815600287445;7.9709122377322847 -9.7013942047782535;15.820294846644954 -18.61720498856182;-9.7316607218117159 4.0110022001480994;15.324027804528862 -18.000484133827587;-3.3787408612522478 7.1815722089969043;-4.8328144040035816 2.5506167863052398;-0.83659588238840765 2.414200242589557];

% Layer 2
b2 = [0.38055782335411237;0.3142037124869006;-0.233810818302193];
LW2_1 = [-2.3229150282980036 -3.3361921183316277 -0.54064206953390681 9.1340148739482903 1.403102287774594 0.21616572488766395 -7.8930068688999224 1.3364772942718 0.5467095862775263 2.3779403645508355;0.045743716422340271 -1.6730590128216523 0.4422835779585525 4.0991837168786223 -7.0613963199034933 -0.24303644028176566 5.0382448503001367 -2.6918589439133784 1.0978649107085563 3.1986728149559043;0.74340781771285103 0.82845355437127977 0.1374698874418559 1.7995116872934316 -0.63333440324389811 -0.16687436507837705 0.32676669213092885 -0.45439182669330247 0.17892551645864785 0.84673969164334051];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [10;16.1592427081696;18.3438430135025];
y1_step1.xoffset = [-0.1;-0.1;-0.1];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(1,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),2,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
